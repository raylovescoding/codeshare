<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>基数排序</title>
    <url>/2025/08/29/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[题目描述基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。基数排序的核心思想是从低位到高位（或从高位到低位）对数据进行排序，每一位的排序都使用稳定的排序算法（通常是计数排序）。

输入格式输入共 2 行，第一行是一个整数 n，表示数组的长度。第二行包含 n 个非负整数，表示待排序的数组。
输出格式输出共 1 行，包含 n 个整数，表示排序后的数组（升序排列）。
数据范围1 ≤ n ≤ 100000 ≤ 数组元素 ≤ 1000000
输入样例：
8170 45 75 90 802 24 2 66

输出样例：
2 24 45 66 75 90 170 802

注意事项

基数排序的时间复杂度为 O(d*(n+k))，其中 d 是最大数的位数，n 是数组的长度，k 是基数（这里为10）。
基数排序的空间复杂度为 O(n+k)。
基数排序是稳定的排序算法。
基数排序特别适合于整数排序，尤其是当数据范围较大但位数较少时。

代码实现
#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;// 获取x的第d位数字（从0开始计数）int getDigit(int x, int d)&#123;    int divisor = 1;    for (int i = 0; i &lt; d; i++)    &#123;        divisor *= 10;    &#125;    return (x / divisor) % 10;&#125;// 基数排序函数（从低位到高位排序）void radixSort(int a[], int n)&#123;    // 找出数组中的最大值    int max_value = a[0];    for (int i = 1; i &lt; n; i++)    &#123;        if (a[i] &gt; max_value)        &#123;            max_value = a[i];        &#125;    &#125;        // 计算最大值的位数    int max_digits = 0;    while (max_value &gt; 0)    &#123;        max_digits++;        max_value /= 10;    &#125;        // 创建10个桶（对应0-9这10个数字）    vector&lt;vector&lt;int&gt;&gt; buckets(10);        // 从低位到高位进行排序    for (int d = 0; d &lt; max_digits; d++)    &#123;        // 将元素分配到对应的桶中        for (int i = 0; i &lt; n; i++)        &#123;            int digit = getDigit(a[i], d);            buckets[digit].push_back(a[i]);        &#125;                // 将桶中的元素合并回原数组        int index = 0;        for (int i = 0; i &lt; 10; i++)        &#123;            for (int j = 0; j &lt; buckets[i].size(); j++)            &#123;                a[index++] = buckets[i][j];            &#125;            buckets[i].clear(); // 清空桶，为下一轮排序做准备        &#125;    &#125;&#125;int main()&#123;    int n;    cin &gt;&gt; n;    int a[n];        for (int i = 0; i &lt; n; i++)    &#123;        cin &gt;&gt; a[i];    &#125;        radixSort(a, n); // 对整个数组进行基数排序        // 输出排序后的数组    for (int i = 0; i &lt; n; i++)    &#123;        cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;        return 0;&#125;

时间复杂度

时间复杂度：O(d*(n+k))，其中 d 是最大数的位数，n 是数组的长度，k 是基数（这里为10）。
空间复杂度：O(n+k)。

代码解释

基数排序的核心思想是从低位到高位（或从高位到低位）对数据进行排序，每一位的排序都使用稳定的排序算法。
在这个实现中，我们从低位到高位进行排序，每一位的排序都使用计数排序的思想（通过桶来实现）。
首先，我们找出数组中的最大值，并计算其位数。
然后，我们从最低位开始，对每一位进行排序：
根据当前位的数字，将元素分配到对应的桶中。
将桶中的元素按照顺序合并回原数组。


重复上述过程，直到所有位都排序完成。

]]></content>
      <categories>
        <category>算法基础</category>
      </categories>
      <tags>
        <tag>C++;排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数字反转普通版</title>
    <url>/2025/08/28/%E6%95%B0%E5%AD%97%E5%8F%8D%E8%BD%AC%E6%99%AE%E9%80%9A%E7%89%88/</url>
    <content><![CDATA[题目描述给定一个整数，请将该数各个位上数字反转得到一个新数。新数也应满足整数的常见形式，即除非给定的原数为零，否则反转后得到的新数的最高位数字不应为零（参见样例2）。

输入格式输入共 1 行，一个整数 N。
输出格式输出共 1 行，一个整数，表示反转后的新数。
数据范围-1,000,000,000 ≤ N≤ 1,000,000,000。
输入样例1：
123

输出样例1：
321

输入样例2：
-380

输出样例2：
-83

注意事项

当输入的整数为负数时，需要在反转后保持负号。
反转后的整数不能超过 int 类型的范围。

代码实现
#include &lt;iostream&gt;using namespace std;int main()&#123;    int n;    cin &gt;&gt; n;    int res = 0;    while (n)    &#123;        res = res * 10 + n % 10;        n /= 10;    &#125;    cout &lt;&lt; res &lt;&lt; endl;    return 0;&#125;

时间复杂度

时间复杂度：O(logn)，其中 n 为输入的整数。
空间复杂度：O(1)。

代码解释

我们使用一个循环来反转整数的每一位。
在每一次循环中，我们将整数 n 对 10 取模，得到 n 的个位数，将个位数添加到结果 res 的末尾。
然后，我们将整数 n 除以 10，去掉个位数。
重复以上步骤，直到整数 n 变为 0。
最后，输出结果 res。

]]></content>
      <categories>
        <category>算法基础</category>
      </categories>
      <tags>
        <tag>C++;</tag>
      </tags>
  </entry>
  <entry>
    <title>编程输出“Hello,World”</title>
    <url>/2025/08/24/%E7%BC%96%E7%A8%8B%E8%BE%93%E5%87%BA%E2%80%9CHello-World%E2%80%9D/</url>
    <content><![CDATA[题目描述编写一个C++程序，输出“Hello,World!”。

输入无
输出Hello,World!
代码
#include &lt;iostream&gt;using namespace std;int main()&#123;    cout &lt;&lt; &quot;Hello,World!&quot; &lt;&lt; endl;    return 0;&#125;
代码解释

包含头文件iostream，用于输入输出流。
使用命名空间std，避免使用std::前缀。
定义主函数main，程序从这里开始执行。
使用cout输出“Hello,World!”，endl表示换行。
返回0表示程序正常结束。

]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>选择排序</title>
    <url>/2025/08/29/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[题目描述选择排序是一种简单直观的排序算法。它的工作原理是每次从未排序的部分选出最小（或最大）的元素，放到已排序部分的末尾，直到所有元素均排序完毕。

输入格式输入共 2 行，第一行是一个整数 n，表示数组的长度。第二行包含 n 个整数，表示待排序的数组。
输出格式输出共 1 行，包含 n 个整数，表示排序后的数组（升序排列）。
数据范围1 ≤ n ≤ 1000-1000 ≤ 数组元素 ≤ 1000
输入样例：
68 4 2 5 1 7

输出样例：
1 2 4 5 7 8

注意事项

选择排序的时间复杂度为 O(n²)，空间复杂度为 O(1)。
选择排序是不稳定的排序算法。

代码实现
#include &lt;iostream&gt;using namespace std;int main()&#123;    int n;    cin &gt;&gt; n;    int a[n];    for (int i = 0; i &lt; n; i++)    &#123;        cin &gt;&gt; a[i];    &#125;        // 选择排序    for (int i = 0; i &lt; n - 1; i++)    &#123;        int min_index = i; // 记录当前未排序部分中最小元素的索引        for (int j = i + 1; j &lt; n; j++)        &#123;            if (a[j] &lt; a[min_index])            &#123;                min_index = j;            &#125;        &#125;        // 将找到的最小元素与未排序部分的第一个元素交换        if (min_index != i)        &#123;            int temp = a[i];            a[i] = a[min_index];            a[min_index] = temp;        &#125;    &#125;        // 输出排序后的数组    for (int i = 0; i &lt; n; i++)    &#123;        cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;        return 0;&#125;

时间复杂度

时间复杂度：O(n²)，其中 n 为数组的长度。
空间复杂度：O(1)。

代码解释

我们使用两层循环来实现选择排序。外层循环控制已排序部分的末尾位置，内层循环在未排序部分中寻找最小元素。
在每一轮中，我们从未排序部分（从i+1到n-1）找到最小的元素，并记录其索引。
然后将找到的最小元素与未排序部分的第一个元素（即位置i的元素）交换位置。
重复上述过程，直到整个数组排序完成。

]]></content>
      <categories>
        <category>算法基础</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
</search>
