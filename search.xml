<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>数字反转普通版</title>
    <url>/2025/08/28/%E6%95%B0%E5%AD%97%E5%8F%8D%E8%BD%AC%E6%99%AE%E9%80%9A%E7%89%88/</url>
    <content><![CDATA[题目描述给定一个整数，请将该数各个位上数字反转得到一个新数。新数也应满足整数的常见形式，即除非给定的原数为零，否则反转后得到的新数的最高位数字不应为零（参见样例2）。

输入格式输入共 1 行，一个整数 N。
输出格式输出共 1 行，一个整数，表示反转后的新数。
数据范围-1,000,000,000 ≤ N≤ 1,000,000,000。
输入样例1：
123

输出样例1：
321

输入样例2：
-380

输出样例2：
-83

注意事项

当输入的整数为负数时，需要在反转后保持负号。
反转后的整数不能超过 int 类型的范围。

代码实现
#include &lt;iostream&gt;using namespace std;int main()&#123;    int n;    cin &gt;&gt; n;    int res = 0;    while (n)    &#123;        res = res * 10 + n % 10;        n /= 10;    &#125;    cout &lt;&lt; res &lt;&lt; endl;    return 0;&#125;

时间复杂度

时间复杂度：O(logn)，其中 n 为输入的整数。
空间复杂度：O(1)。

代码解释

我们使用一个循环来反转整数的每一位。
在每一次循环中，我们将整数 n 对 10 取模，得到 n 的个位数，将个位数添加到结果 res 的末尾。
然后，我们将整数 n 除以 10，去掉个位数。
重复以上步骤，直到整数 n 变为 0。
最后，输出结果 res。

]]></content>
      <categories>
        <category>算法基础</category>
      </categories>
      <tags>
        <tag>C++;</tag>
      </tags>
  </entry>
  <entry>
    <title>编程输出“Hello,World”</title>
    <url>/2025/08/24/%E7%BC%96%E7%A8%8B%E8%BE%93%E5%87%BA%E2%80%9CHello-World%E2%80%9D/</url>
    <content><![CDATA[题目描述编写一个C++程序，输出“Hello,World!”。

输入无
输出Hello,World!
代码
#include &lt;iostream&gt;using namespace std;int main()&#123;    cout &lt;&lt; &quot;Hello,World!&quot; &lt;&lt; endl;    return 0;&#125;
代码解释

包含头文件iostream，用于输入输出流。
使用命名空间std，避免使用std::前缀。
定义主函数main，程序从这里开始执行。
使用cout输出“Hello,World!”，endl表示换行。
返回0表示程序正常结束。

]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>选择排序</title>
    <url>/2025/08/29/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[题目描述选择排序是一种简单直观的排序算法。它的工作原理是每次从未排序的部分选出最小（或最大）的元素，放到已排序部分的末尾，直到所有元素均排序完毕。

输入格式输入共 2 行，第一行是一个整数 n，表示数组的长度。第二行包含 n 个整数，表示待排序的数组。
输出格式输出共 1 行，包含 n 个整数，表示排序后的数组（升序排列）。
数据范围1 ≤ n ≤ 1000-1000 ≤ 数组元素 ≤ 1000
输入样例：
68 4 2 5 1 7

输出样例：
1 2 4 5 7 8

注意事项

选择排序的时间复杂度为 O(n²)，空间复杂度为 O(1)。
选择排序是不稳定的排序算法。

代码实现
#include &lt;iostream&gt;using namespace std;int main()&#123;    int n;    cin &gt;&gt; n;    int a[n];    for (int i = 0; i &lt; n; i++)    &#123;        cin &gt;&gt; a[i];    &#125;        // 选择排序    for (int i = 0; i &lt; n - 1; i++)    &#123;        int min_index = i; // 记录当前未排序部分中最小元素的索引        for (int j = i + 1; j &lt; n; j++)        &#123;            if (a[j] &lt; a[min_index])            &#123;                min_index = j;            &#125;        &#125;        // 将找到的最小元素与未排序部分的第一个元素交换        if (min_index != i)        &#123;            int temp = a[i];            a[i] = a[min_index];            a[min_index] = temp;        &#125;    &#125;        // 输出排序后的数组    for (int i = 0; i &lt; n; i++)    &#123;        cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;        return 0;&#125;

时间复杂度

时间复杂度：O(n²)，其中 n 为数组的长度。
空间复杂度：O(1)。

代码解释

我们使用两层循环来实现选择排序。外层循环控制已排序部分的末尾位置，内层循环在未排序部分中寻找最小元素。
在每一轮中，我们从未排序部分（从i+1到n-1）找到最小的元素，并记录其索引。
然后将找到的最小元素与未排序部分的第一个元素（即位置i的元素）交换位置。
重复上述过程，直到整个数组排序完成。

]]></content>
      <categories>
        <category>算法基础</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
</search>
